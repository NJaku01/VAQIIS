# --------------------------------------------------------------------------------------------------------------------------------
# Predefine functions for later use
###
# Function to check if a package is already installed
usePackage <- function(p)
{
if (!is.element(p, installed.packages()[,1]))
install.packages(p, dep = TRUE)
require(p, character.only = TRUE)
}
###
# Function to convert GPS-coordinates
#convert latitude and longitude from ddmm.mmmm (dddmm.mmmm) format to decimal
convertISO6709 <- function( lat, lon ) {
# will just do lat and lon together, as the process is the same for both
# It's simpler to do the arithmetic on positive numbers, we'll add the signs
#  back in at the end.
latlon <- cbind(lat,lon)
sgns   <- sign(latlon)
latlon <- abs(latlon)
# grab the MM.MMMM bit, which is always <100. '%%' is modular arithmetic.
mm <- latlon %% 100
# grab the DD bit. Divide by 100 because of the MM.MMMM bit.
dd <- (latlon - mm)/100
# convert to decimal degrees, don't forget to add the signs back!
out_latlon <- (dd+mm/60) * sgns
return(out_latlon)
}
# --------------------------------------------------------------------------------------------------------------------------------
# Load required packages
# Packages for maps in R
usePackage("ggplot2")
usePackage("rlang")
usePackage("OpenStreetMap")
# Packages to order data
usePackage("magrittr")
usePackage("plyr")
usePackage("dplyr") #falls es hier einen Fehler gibt muss das Paket per Hand installiert werden
# --------------------------------------------------------------------------------------------------------------------------------
# Subset data to single rides by choosing start and end date of the ride
# if no subset should be supplied, just leave out or enter the dates of the entire period.
#Messperiode ("2017-11-13 00:00:00.0") als Startzeitpunkt und
#nach Ende der Messperiode ("2017-12-31 00:00:00.0") als Endzeitpunkt eingeben
# Start and end for 1 Hz data
# Ride 1
start_ride1 <- strptime("2019-10-29 11:37:40", "%Y-%m-%d %H:%M:%S")
end_ride1 <- strptime("2019-10-29 12:36:10", "%Y-%m-%d %H:%M:%S")
start_ride1_1<- strptime("2019-10-29 11:37:40", "%Y-%m-%d %H:%M:%S")
end_ride1_1 <- strptime("2019-10-29 12:00:00", "%Y-%m-%d %H:%M:%S")
start_ride1_2<- strptime("2019-10-29 12:15:00", "%Y-%m-%d %H:%M:%S")
end_ride1_2 <- strptime("2019-10-29 12:36:10", "%Y-%m-%d %H:%M:%S")
# --------------------------------------------------------------------------------------------------------------------------------
# Read in data files
# Set Working directory
# setwd(choose.dir()) # Uncomment if necessary, but only works for Windows operating system
setwd("//geo.uni-muenster.de/iloek/KLIMA/Klimatologie/Studienprojekte/Studienprojekt_2019_2020_BSc/Studienprojekt_19_20/Konvertierte Daten")
# Data fast table  #
####################
# Two different ways of reading in data:
# 1. Read in a single file: If you only need to control a single ride etc. use this code
# 2. Read in several files and bind them together to a large data set:
#    If you want to look at the whole period, apply statistics to all data etc. use this code
# We skip the first 4 lines in each file, which contain only meta data
# The header is then derived from one of the files in the directory:
# Define column names for the data table
# You have to insert the name of one of the files
d_1Hz_header=read.table("TOA5_fasttable5_2019_10_31_0958.dat", sep = ",", dec = ".", header = F,
skip = 1, nrows = 1, as.is = T)
# 2. Read in several files and bind them together to a large data set
# List all files you want to bind together by choosing them by name.
# Here every file which begins with "TOA5_f" is chosen.
files_1Hz=list.files(pattern ="^TOA5_f")
# Read in all files from the list and bind them together
# CAUTION: The files have to have the SAME number of columns!
for(i in files_1Hz) {
if(!exists("d_1Hz_multi")) {
d_1Hz_multi=read.table(i, sep = ",", dec = ".", header = F, skip = 4,
na.strings = c("<NA>", "NAN"), stringsAsFactors = FALSE)
} else {
temp_d_1Hz_multi=read.table(i, sep = ",", dec = ".", header = F, skip = 4,
na.strings = c("<NA>", "NAN"), stringsAsFactors = FALSE)
d_1Hz_multi=rbind(d_1Hz_multi, temp_d_1Hz_multi)
remove(temp_d_1Hz_multi)
}
}
# Add column names to dataframe d_1Hz_multi
colnames(d_1Hz_multi)=d_1Hz_header
remove(d_1Hz_header)
d_1Hz_multi$TIMESTAMP=strptime(d_1Hz_multi$TIMESTAMP, "%Y-%m-%d %H:%M:%OS")
d_ride1a_1Hz <- subset(d_1Hz_multi, TIMESTAMP >= start_ride1_1 & TIMESTAMP <= end_ride1_1 )
# Multi data table 1Hz
latlong_conv=convertISO6709(d_ride1a_1Hz_multi$rmclatitude,d_ride1a_1Hz_multi$rmclongitude)
# Multi data table 1Hz
latlong_conv=convertISO6709(d_ride1a_1Hz$rmclatitude,d_ride1a_1Hz$rmclongitude)
# Ride1 1Hz
latlong_conv_ride1a=convertISO6709(d_ride1a_1Hz$rmclatitude,d_ride1a_1Hz$rmclongitude)
####
# Test
latlong_conv_ride1a=convertISO6709(test$rmclatitude,test$rmclongitude)
####
# Test
latlong_conv_ride1a=convertISO6709(d_ride1a_1Hz$rmclatitude,d_ride1a_1Hz$rmclongitude)
# Single data table
df <- data.frame(lon=latlong_conv[,2], lat=latlong_conv[,1])
test1_1<-cbind(d_ride1a_1Hz,df)
# Loading Muenster map:
map = openmap(upperLeft=c(lat= 51.97,   lon= 7.595), lowerRight = c(lat= 51.95,   lon= 7.64), type = "esri-topo",
minNumTiles = 15) # "osm" kann durch andere Versionen ausgetauscht werden
